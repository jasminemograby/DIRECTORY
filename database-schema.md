# Directory Microservice - Database Schema Design

## PostgreSQL Schema with Multi-Tenancy

### Core Tables

#### 1. Companies Table
```sql
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    industry VARCHAR(100),
    size VARCHAR(50), -- 'startup', 'small', 'medium', 'large', 'enterprise'
    location VARCHAR(255),
    website VARCHAR(255),
    logo_url TEXT,
    description TEXT,
    kpis JSONB, -- Company-specific KPIs and metrics
    settings JSONB, -- Company-specific settings and configurations
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'suspended', 'inactive'
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID, -- HR Admin who created the company
    verified_at TIMESTAMP WITH TIME ZONE,
    verified_by UUID
);

-- Indexes for performance
CREATE INDEX idx_companies_name ON companies(name);
CREATE INDEX idx_companies_industry ON companies(industry);
CREATE INDEX idx_companies_status ON companies(status);
CREATE INDEX idx_companies_created_at ON companies(created_at);
```

#### 2. Departments Table
```sql
CREATE TABLE departments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    manager_id UUID, -- References employees table
    budget DECIMAL(15,2),
    location VARCHAR(255),
    settings JSONB,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Ensure department names are unique within a company
    UNIQUE(company_id, name)
);

-- Indexes
CREATE INDEX idx_departments_company_id ON departments(company_id);
CREATE INDEX idx_departments_manager_id ON departments(manager_id);
CREATE INDEX idx_departments_status ON departments(status);
```

#### 3. Teams Table
```sql
CREATE TABLE teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    department_id UUID NOT NULL REFERENCES departments(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    team_lead_id UUID, -- References employees table
    max_size INTEGER DEFAULT 10,
    settings JSONB,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Ensure team names are unique within a department
    UNIQUE(department_id, name)
);

-- Indexes
CREATE INDEX idx_teams_company_id ON teams(company_id);
CREATE INDEX idx_teams_department_id ON teams(department_id);
CREATE INDEX idx_teams_team_lead_id ON teams(team_lead_id);
CREATE INDEX idx_teams_status ON teams(status);
```

#### 4. Employees Table
```sql
CREATE TABLE employees (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    department_id UUID REFERENCES departments(id) ON DELETE SET NULL,
    team_id UUID REFERENCES teams(id) ON DELETE SET NULL,
    
    -- Basic Information
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    employee_id VARCHAR(50), -- Company-specific employee ID
    
    -- Professional Information
    role VARCHAR(50) NOT NULL, -- 'employee', 'team_lead', 'manager', 'hr_admin'
    job_title VARCHAR(255),
    level VARCHAR(50), -- 'junior', 'mid', 'senior', 'lead', 'principal'
    career_path VARCHAR(100),
    
    -- Personal Information
    date_of_birth DATE,
    hire_date DATE NOT NULL,
    location VARCHAR(255),
    timezone VARCHAR(50),
    
    -- Profile Information
    bio TEXT,
    ai_generated_bio TEXT, -- Generated by Gemini API
    value_proposition TEXT, -- AI-generated value proposition
    profile_picture_url TEXT,
    
    -- Skills and Competencies
    skills JSONB, -- Array of skill objects with verification status
    verified_skills JSONB, -- Skills verified by Skills Engine
    skill_gaps JSONB, -- Identified skill gaps
    relevance_score DECIMAL(3,2), -- Score from Skills Engine (0.00-1.00)
    
    -- Learning and Development
    learning_goals JSONB,
    completed_courses JSONB,
    enrolled_courses JSONB,
    training_requests JSONB,
    
    -- External Data Integration
    linkedin_url VARCHAR(255),
    github_username VARCHAR(100),
    credly_profile_url VARCHAR(255),
    youtube_channel_url VARCHAR(255),
    orcid_id VARCHAR(50),
    external_data JSONB, -- Cached external API data
    
    -- Status and Settings
    status VARCHAR(20) DEFAULT 'active', -- 'active', 'inactive', 'terminated'
    is_trainer BOOLEAN DEFAULT FALSE,
    trainer_type VARCHAR(20), -- 'internal', 'external'
    ai_editing_enabled BOOLEAN DEFAULT FALSE,
    notification_preferences JSONB,
    
    -- Audit Fields
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID, -- HR Admin who created the employee
    last_login_at TIMESTAMP WITH TIME ZONE,
    
    -- Ensure email is unique within company
    UNIQUE(company_id, email),
    UNIQUE(company_id, employee_id)
);

-- Indexes
CREATE INDEX idx_employees_company_id ON employees(company_id);
CREATE INDEX idx_employees_department_id ON employees(department_id);
CREATE INDEX idx_employees_team_id ON employees(team_id);
CREATE INDEX idx_employees_email ON employees(email);
CREATE INDEX idx_employees_role ON employees(role);
CREATE INDEX idx_employees_status ON employees(status);
CREATE INDEX idx_employees_is_trainer ON employees(is_trainer);
CREATE INDEX idx_employees_hire_date ON employees(hire_date);
```

#### 5. Trainers Table (Extended Employee Information)
```sql
CREATE TABLE trainers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    employee_id UUID NOT NULL REFERENCES employees(id) ON DELETE CASCADE,
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    
    -- Trainer Specific Information
    trainer_type VARCHAR(20) NOT NULL, -- 'internal', 'external'
    company_permission VARCHAR(20) DEFAULT 'internal', -- 'internal', 'system_wide'
    ai_editing_enabled BOOLEAN DEFAULT FALSE,
    
    -- Teaching Information
    specializations JSONB, -- Array of teaching specializations
    teaching_experience INTEGER DEFAULT 0, -- Years of experience
    course_history JSONB, -- History of taught courses
    teaching_requests JSONB, -- Pending and approved teaching requests
    
    -- Content and Skills
    content_permissions JSONB, -- What content they can create/edit
    verified_teaching_skills JSONB, -- Teaching skills verified by Skills Engine
    teaching_rating DECIMAL(3,2), -- Average teaching rating
    total_students_taught INTEGER DEFAULT 0,
    
    -- Availability and Scheduling
    availability JSONB, -- Availability schedule
    max_courses_per_period INTEGER DEFAULT 5,
    preferred_teaching_methods JSONB, -- 'instructor_led', 'workshop', 'mentoring'
    
    -- External Profiles
    external_profiles JSONB, -- External teaching profiles and certifications
    
    -- Status and Settings
    status VARCHAR(20) DEFAULT 'active',
    is_available_for_teaching BOOLEAN DEFAULT TRUE,
    auto_approve_requests BOOLEAN DEFAULT FALSE,
    
    -- Audit Fields
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_trainers_employee_id ON trainers(employee_id);
CREATE INDEX idx_trainers_company_id ON trainers(company_id);
CREATE INDEX idx_trainers_type ON trainers(trainer_type);
CREATE INDEX idx_trainers_status ON trainers(status);
CREATE INDEX idx_trainers_available ON trainers(is_available_for_teaching);
```

#### 6. Training Requests Table
```sql
CREATE TABLE training_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    employee_id UUID NOT NULL REFERENCES employees(id) ON DELETE CASCADE,
    
    -- Request Information
    request_type VARCHAR(20) NOT NULL, -- 'career_path', 'skill_driven', 'instructor_led'
    title VARCHAR(255) NOT NULL,
    description TEXT,
    priority VARCHAR(10) DEFAULT 'medium', -- 'low', 'medium', 'high', 'urgent'
    
    -- Training Details
    training_category VARCHAR(100),
    required_skills JSONB, -- Skills required for this training
    target_skills JSONB, -- Skills to be developed
    estimated_duration INTEGER, -- Duration in hours
    preferred_format VARCHAR(50), -- 'online', 'in_person', 'hybrid'
    
    -- Approval Workflow
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'in_progress', 'completed', 'cancelled'
    requested_by UUID NOT NULL REFERENCES employees(id),
    approved_by UUID REFERENCES employees(id),
    rejected_by UUID REFERENCES employees(id),
    approval_notes TEXT,
    rejection_reason TEXT,
    
    -- Training Assignment
    assigned_trainer_id UUID REFERENCES employees(id),
    assigned_course_id VARCHAR(255), -- Reference to course in Content Studio
    start_date DATE,
    end_date DATE,
    actual_duration INTEGER, -- Actual duration in hours
    
    -- Progress Tracking
    progress_percentage DECIMAL(5,2) DEFAULT 0.00,
    completion_date DATE,
    feedback JSONB, -- Employee feedback on training
    trainer_feedback JSONB, -- Trainer feedback on employee
    
    -- Integration Data
    marketplace_match_data JSONB, -- Data from Marketplace service
    content_studio_data JSONB, -- Data from Content Studio
    skills_engine_data JSONB, -- Data from Skills Engine
    
    -- Audit Fields
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_training_requests_company_id ON training_requests(company_id);
CREATE INDEX idx_training_requests_employee_id ON training_requests(employee_id);
CREATE INDEX idx_training_requests_status ON training_requests(status);
CREATE INDEX idx_training_requests_type ON training_requests(request_type);
CREATE INDEX idx_training_requests_approved_by ON training_requests(approved_by);
CREATE INDEX idx_training_requests_assigned_trainer ON training_requests(assigned_trainer_id);
CREATE INDEX idx_training_requests_created_at ON training_requests(created_at);
```

#### 7. Audit Log Table
```sql
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    
    -- Action Information
    action VARCHAR(100) NOT NULL, -- 'create', 'update', 'delete', 'approve', 'reject'
    entity_type VARCHAR(50) NOT NULL, -- 'company', 'employee', 'trainer', 'training_request'
    entity_id UUID NOT NULL,
    
    -- User Information
    performed_by UUID NOT NULL REFERENCES employees(id),
    performed_by_role VARCHAR(50),
    
    -- Change Information
    old_values JSONB,
    new_values JSONB,
    change_summary TEXT,
    
    -- Request Information
    ip_address INET,
    user_agent TEXT,
    request_id VARCHAR(100),
    
    -- Timestamp
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_audit_logs_company_id ON audit_logs(company_id);
CREATE INDEX idx_audit_logs_entity_type ON audit_logs(entity_type);
CREATE INDEX idx_audit_logs_entity_id ON audit_logs(entity_id);
CREATE INDEX idx_audit_logs_performed_by ON audit_logs(performed_by);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
```

### Row-Level Security (RLS) Policies

```sql
-- Enable RLS on all tables
ALTER TABLE companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE departments ENABLE ROW LEVEL SECURITY;
ALTER TABLE teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE trainers ENABLE ROW LEVEL SECURITY;
ALTER TABLE training_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Company-based access policies
CREATE POLICY company_isolation_policy ON companies
    FOR ALL TO authenticated
    USING (id = current_setting('app.current_company_id')::UUID);

CREATE POLICY department_company_isolation ON departments
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY team_company_isolation ON teams
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY employee_company_isolation ON employees
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY trainer_company_isolation ON trainers
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY training_request_company_isolation ON training_requests
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);

CREATE POLICY audit_log_company_isolation ON audit_logs
    FOR ALL TO authenticated
    USING (company_id = current_setting('app.current_company_id')::UUID);
```

### Database Functions and Triggers

```sql
-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers for updated_at
CREATE TRIGGER update_companies_updated_at BEFORE UPDATE ON companies
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_departments_updated_at BEFORE UPDATE ON departments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_teams_updated_at BEFORE UPDATE ON teams
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_employees_updated_at BEFORE UPDATE ON employees
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_trainers_updated_at BEFORE UPDATE ON trainers
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_training_requests_updated_at BEFORE UPDATE ON training_requests
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to create audit log entry
CREATE OR REPLACE FUNCTION create_audit_log()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_logs (
        company_id,
        action,
        entity_type,
        entity_id,
        performed_by,
        old_values,
        new_values,
        change_summary
    ) VALUES (
        COALESCE(NEW.company_id, OLD.company_id),
        TG_OP,
        TG_TABLE_NAME,
        COALESCE(NEW.id, OLD.id),
        current_setting('app.current_user_id')::UUID,
        CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW) ELSE NULL END,
        TG_OP || ' operation on ' || TG_TABLE_NAME
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql';

-- Audit triggers for all tables
CREATE TRIGGER audit_companies AFTER INSERT OR UPDATE OR DELETE ON companies
    FOR EACH ROW EXECUTE FUNCTION create_audit_log();

CREATE TRIGGER audit_employees AFTER INSERT OR UPDATE OR DELETE ON employees
    FOR EACH ROW EXECUTE FUNCTION create_audit_log();

CREATE TRIGGER audit_trainers AFTER INSERT OR UPDATE OR DELETE ON trainers
    FOR EACH ROW EXECUTE FUNCTION create_audit_log();

CREATE TRIGGER audit_training_requests AFTER INSERT OR UPDATE OR DELETE ON training_requests
    FOR EACH ROW EXECUTE FUNCTION create_audit_log();
```

## Multi-Tenancy Implementation

### 1. **Company-Based Data Isolation**
- All tables include `company_id` foreign key
- Row-Level Security (RLS) policies enforce company isolation
- Middleware sets `app.current_company_id` for each request

### 2. **Role-Based Access Control**
- Employee roles: `employee`, `team_lead`, `manager`, `hr_admin`
- Role inheritance: Managers inherit team lead capabilities, etc.
- Permission-based access to different data and operations

### 3. **Data Relationships**
- Company → Departments → Teams → Employees
- Trainers extend Employee information
- Training Requests link to Employees and Trainers
- Audit Logs track all changes with company isolation

### 4. **Performance Optimization**
- Strategic indexing on frequently queried columns
- Company-based partitioning for large datasets
- JSONB columns for flexible data storage
- Efficient foreign key relationships
